# Category View - Words Management Documentation

## Overview
The Category View page (`src/pages/CategoryView.tsx`) manages displaying, adding, editing, and deleting words within a specific category. All word data is fetched from and persisted to a **backend API**.

---

## 1. Fetching Words

### Data Flow
1. **Load Category**: On page mount, the component uses `categoryId` from URL params to find the category across all languages
2. **Fetch from Backend**: Words are retrieved via API call to the backend with filters, sorting, and pagination parameters
3. **Initialize Data**: If no data exists, an empty array with pagination metadata is returned

### API Endpoint
```
GET /api/languages/{languageId}/categories/{categoryId}/words
```

### Query Parameters
```typescript
{
  // Pagination
  page?: number;           // Page number (default: 1)
  pageSize?: number;       // Items per page (default: 20)
  
  // Sorting
  sort?: string;          // Column name: "word" | "comment" | "mechanism" | "chosen" | "repeated" | "lastTimestampRepeated" | "created"
  order?: "asc" | "desc"; // Sort direction
  
  // Filters
  accepted?: boolean;     // Filter by acceptance status
  mechanism?: string;     // "BASIC" | "TABLE" | "ALL"
  searchText?: string;    // Search in word text and comments
  chosen?: boolean;       // Filter by chosen status
}
```

### Response Structure
```typescript
{
  page: number;           // Current page number
  pageSize: number;       // Items per page
  total: number;          // Total number of items
  sort: string | null;    // Current sort column
  order: "asc" | "desc" | null; // Current sort direction
  singlePage: boolean;    // Whether all items fit in one page
  items: Word[];          // Array of words
}
```

### Word DTO Structure
```typescript
{
  id: number;
  accepted: boolean;
  comment: string;
  resetTimestamp: number | null;
  mechanism: "BASIC" | "TABLE";
  chosen: boolean;
  toRepeat: boolean;
  repeated: number;
  lastTimestampRepeated: number | null;
  created: number;
  wordParts: WordPart[];
  wordStats: WordStat[];
  inCategories: string[];
}
```

### Code Location
- **File**: `src/pages/CategoryView.tsx`
- **Function**: `useEffect` hook
- **Service**: `src/services/wordService.ts` - `getWords()`

### Implementation Example
```typescript
const loadWords = async () => {
  try {
    const response = await wordService.getWords(
      categoryId,
      {
        accepted: true,
        mechanism: mechanismFilter,
        searchText: textFilter,
      },
      {
        page: currentPage,
        pageSize: pageSize,
      },
      {
        column: sortColumn,
        direction: sortDirection,
      }
    );
    
    setWords(response.items);
    setTotalPages(response.totalPages);
  } catch (error) {
    toast.error("Failed to load words");
  }
};
```

### Key Features
- Words are filtered into two groups: **accepted** and **unaccepted** (pending)
- Each group has separate pagination, sorting, and filtering
- Server-side pagination, filtering, and sorting for better performance
- Real-time data synchronization with backend

---

## 2. Adding New Words

### User Flow
1. Click **"Add New Word"** button
2. Modal opens with `AddWordForm` component
3. Fill in word details and parts
4. Submit form
5. Word is sent to backend API
6. On success, word list is refreshed

### API Endpoint
```
POST /api/languages/{languageId}/categories/{categoryId}/words
```

### Request Body Structure
```typescript
{
  comment: string;
  mechanism: "BASIC" | "TABLE";
  wordParts: [
    {
      word: string;           // Main text content
      basicWord: string;      // Optional base form or translation
      answer: boolean;        // true = answer part, false = question part
      toSpeech: boolean;      // Enable text-to-speech
      position: number;       // Order in sequence (0-based)
      isSeparator?: boolean;  // Optional: is this a separator
      separatorType?: "ENTER" | "TAB" | "MULTI_DASH"; // Type if separator
    }
  ];
  // Initial values (set by backend if not provided)
  accepted?: boolean;         // Default: false
  chosen?: boolean;           // Default: false
  toRepeat?: boolean;         // Default: false
  inCategories?: string[];    // Array of category names, Default: []
}
```

### Response Structure
```typescript
{
  id: number;                    // Generated by backend
  comment: string;
  mechanism: "BASIC" | "TABLE";
  wordParts: WordPart[];
  accepted: boolean;
  chosen: boolean;
  toRepeat: boolean;
  repeated: number;              // Default: 0
  lastTimestampRepeated: number | null;  // Default: null
  created: number;               // Timestamp set by backend
  resetTimestamp: number | null; // Default: null
  wordStats: WordStat[];         // Default: []
  inCategories: string[];
}
```

### Data Structure - Word Parts
Words consist of multiple **word parts** that can be:
- **Question parts**: Text that forms the question (answer: false)
- **Answer parts**: Text that should be matched (answer: true)
- **Separators**: Special formatting (ENTER, TAB, MULTI_DASH)

Each word part has:
- `word`: Main text content
- `basicWord`: Optional base form or translation
- `answer`: Boolean flag (true = answer part, false = question part)
- `toSpeech`: Enable text-to-speech for this part
- `position`: Order in the sequence
- `isSeparator`: Whether this is a separator element
- `separatorType`: Type of separator (if applicable)

### Component Chain
1. **CategoryView** → Opens `WordFormModal`
2. **WordFormModal** → Renders `AddWordForm`
3. **AddWordForm** → Handles form logic and submission
4. **wordService.createWord()** → Sends POST request to backend

### Code Location
- **Modal**: `src/components/WordFormModal.tsx`
- **Form**: `src/components/AddWordForm.tsx`
- **Handler**: `CategoryView.tsx` - `handleWordAdded()` function
- **Service**: `src/services/wordService.ts` - `createWord()`

### Implementation
```typescript
const handleWordAdded = async (wordData: WordCreateForm) => {
  try {
    const newWord = await wordService.createWord(categoryId, wordData);
    
    // Refresh the word list from backend
    await loadWords();
    
    toast.success("Word added successfully");
    setIsModalOpen(false);
  } catch (error) {
    toast.error("Failed to add word");
  }
};
```

### Service Method
```typescript
// wordService.ts
createWord: async (categoryId: string, form: WordCreateForm): Promise<Word> => {
  const service = new RequestService();
  const request = new RequestBuilder<WordCreateForm>()
    .url(`/categories/${categoryId}/words`)
    .method(HttpMethod.POST)
    .contentTypeHeader('application/json')
    .body(form)
    .build();

  const res = await service.send<WordCreateForm, Word>(request);
  throwIfError(res, 'Failed to create word');
  return res.body!;
}
```

### Form Features
- **Drag-and-drop**: Reorder word parts using @dnd-kit
- **Keyboard shortcuts**:
  - `Ctrl+;` - Add question part
  - `Ctrl+'` - Add answer part
  - `Ctrl+/` - Add separator
  - `Tab` - Navigate between inputs
- **Special letters**: Language-specific character buttons
- **Mechanism types**: BASIC or TABLE
- **Validation**: All word parts must have content

### Default State
New words are created with:
- 1 question part (answer: false)
- 1 answer part (answer: true, toSpeech: true)
- `accepted: false` (goes to "Pending Words" section)
- `chosen: false`
- `repeated: 0`
- Current timestamp as `created` value (set by backend)
- Empty `wordStats` and `inCategories` arrays

---

## 3. Editing Words

### User Flow
1. **Option 1**: Double-click on a word row in the table
2. **Option 2**: Click the edit icon button in the Actions column
3. Modal opens with pre-filled form
4. Modify word details
5. Submit to update
6. PUT request sent to backend
7. On success, word list is refreshed

### API Endpoint
```
PUT /api/languages/{languageId}/categories/{categoryId}/words/{wordId}
```

### Request Body Structure
```typescript
{
  comment: string;
  mechanism: "BASIC" | "TABLE";
  wordParts: [
    {
      word: string;
      basicWord: string;
      answer: boolean;
      toSpeech: boolean;
      position: number;
      isSeparator?: boolean;
      separatorType?: "ENTER" | "TAB" | "MULTI_DASH";
    }
  ];
  chosen?: boolean;
  toRepeat?: boolean;
  inCategories?: string[];
  // Note: Cannot modify: id, accepted, repeated, created, lastTimestampRepeated, wordStats
}
```

### Response Structure
```typescript
{
  id: number;                    // Unchanged
  comment: string;               // Updated
  mechanism: "BASIC" | "TABLE";  // Updated
  wordParts: WordPart[];         // Updated
  chosen: boolean;               // Updated if provided
  toRepeat: boolean;             // Updated if provided
  inCategories: string[];        // Updated if provided
  // Backend-managed fields (unchanged by this request)
  accepted: boolean;
  repeated: number;
  lastTimestampRepeated: number | null;
  created: number;
  resetTimestamp: number | null;
  wordStats: WordStat[];
}
```

### Code Location
- **Handler**: `CategoryView.tsx` - `handleOpenEditModal()`
- **Same form**: Uses `AddWordForm` with `editWord` prop
- **Service**: `src/services/wordService.ts` - `updateWord()`

### Implementation
```typescript
const handleOpenEditModal = (word: Word) => {
  setEditingWord(word);
  setIsModalOpen(true);
};

const handleWordUpdated = async (wordData: WordUpdateForm) => {
  try {
    await wordService.updateWord(categoryId, editingWord.id, wordData);
    
    // Refresh the word list from backend
    await loadWords();
    
    toast.success("Word updated successfully");
    setIsModalOpen(false);
  } catch (error) {
    toast.error("Failed to update word");
  }
};
```

### Service Method
```typescript
// wordService.ts
updateWord: async (categoryId: string, wordId: number, form: WordUpdateForm): Promise<void> => {
  const service = new RequestService();
  const request = new RequestBuilder<WordUpdateForm>()
    .url(`/categories/${categoryId}/words/${wordId}`)
    .method(HttpMethod.PUT)
    .contentTypeHeader('application/json')
    .body(form)
    .build();

  const res = await service.send<WordUpdateForm, void>(request);
  throwIfError(res, 'Failed to update word');
}
```

### Update Process
1. Modal opens with existing word data
2. Form is pre-populated with all word parts
3. User modifies fields
4. On submit, PUT request sent to backend with updated data
5. Backend validates and updates the word
6. Word list is refreshed to reflect changes
7. Toast notification confirms success

---

## 4. Deleting Words

### User Flow
1. Click the **trash icon** button in the Actions column
2. Word is immediately removed (no confirmation dialog in current implementation)
3. DELETE request sent to backend
4. On success, word list is refreshed
5. Toast notification confirms deletion

### API Endpoint
```
DELETE /api/languages/{languageId}/categories/{categoryId}/words/{wordId}
```

### Request
- **Method**: DELETE
- **Body**: None
- **Path Parameters**: 
  - `languageId`: UUID of the language
  - `categoryId`: UUID of the category
  - `wordId`: Numeric ID of the word

### Response
- **Status**: 204 No Content (on success)
- **Body**: Empty

### Code Location
- **Handler**: `CategoryView.tsx` - `handleDeleteWord()`
- **Service**: `src/services/wordService.ts` - `deleteWord()`

### Implementation
```typescript
const handleDeleteWord = async (wordId: number) => {
  try {
    await wordService.deleteWord(categoryId, wordId);
    
    // Refresh the word list from backend
    await loadWords();
    
    toast.success("Word deleted");
  } catch (error) {
    toast.error("Failed to delete word");
  }
};
```

### Service Method
```typescript
// wordService.ts
deleteWord: async (categoryId: string, wordId: number): Promise<void> => {
  const service = new RequestService();
  const request = new RequestBuilder<void>()
    .url(`/categories/${categoryId}/words/${wordId}`)
    .method(HttpMethod.DELETE)
    .responseAsVoid()
    .build();

  const res = await service.send<void, void>(request);
  throwIfError(res, 'Failed to delete word');
}
```

### Important Notes
- Deletion is **immediate** and **permanent** (no undo)
- Backend should cascade delete related data (wordStats, etc.)
- Recommended: Add confirmation dialog before deletion
- Works for both accepted and unaccepted words

---

## 5. Additional Word Operations

### Accept/Reject (Unaccepted Words)

#### Accept Word
- **Purpose**: Marks word as accepted, moves to main table
- **Endpoint**: `PATCH /api/categories/{categoryId}/words/{wordId}/accept`
- **Method**: PATCH
- **Request Body**: Empty
- **Response**: Updated Word object with `accepted: true`

```typescript
const handleAcceptWord = async (wordId: number) => {
  try {
    await wordService.acceptWord(categoryId, wordId);
    await loadWords();
    toast.success("Word accepted");
  } catch (error) {
    toast.error("Failed to accept word");
  }
};
```

#### Reject Word
- **Purpose**: Permanently removes unaccepted word
- **Endpoint**: `DELETE /api/categories/{categoryId}/words/{wordId}`
- **Method**: DELETE (same as regular delete)
- **Request Body**: Empty
- **Response**: 204 No Content

```typescript
const handleRejectWord = async (wordId: number) => {
  try {
    await wordService.deleteWord(categoryId, wordId);
    await loadWords();
    toast.success("Word rejected");
  } catch (error) {
    toast.error("Failed to reject word");
  }
};
```

---

### Toggle Chosen Status

- **Purpose**: Mark words for repetition exercises
- **Endpoint**: `PATCH /api/categories/{categoryId}/words/{wordId}/chosen`
- **Method**: PATCH

#### Request Body
```typescript
{
  chosen: boolean;  // true or false
}
```

#### Response
```typescript
{
  id: number;
  chosen: boolean;  // Updated value
  // ... other word fields unchanged
}
```

#### Implementation
```typescript
const handleChosenChange = async (wordId: number, checked: boolean) => {
  try {
    await wordService.updateWordChosen(categoryId, wordId, checked);
    
    // Optimistic update
    setWords(words.map(word => 
      word.id === wordId ? { ...word, chosen: checked } : word
    ));
  } catch (error) {
    toast.error("Failed to update chosen status");
    // Revert optimistic update
    await loadWords();
  }
};
```

#### Service Method
```typescript
// wordService.ts
updateWordChosen: async (categoryId: string, wordId: number, chosen: boolean): Promise<void> => {
  const service = new RequestService();
  const request = new RequestBuilder<{ chosen: boolean }>()
    .url(`/categories/${categoryId}/words/${wordId}/chosen`)
    .method(HttpMethod.PATCH)
    .contentTypeHeader('application/json')
    .body({ chosen })
    .build();

  const res = await service.send<{ chosen: boolean }, void>(request);
  throwIfError(res, 'Failed to update chosen status');
}
```

---

### Manage Categories

- **Purpose**: Assign word to multiple categories
- **Endpoint**: `PATCH /api/categories/{categoryId}/words/{wordId}/categories`
- **Method**: PATCH

#### Request Body
```typescript
{
  categoryNames: string[];  // Array of category names
}
```

#### Response
```typescript
{
  id: number;
  inCategories: string[];  // Updated array
  // ... other word fields unchanged
}
```

#### Implementation
```typescript
const handleSaveCategories = async (categoryNames: string[]) => {
  if (!categoriesModalWord) return;
  
  try {
    await wordService.updateWordCategories(
      categoryId, 
      categoriesModalWord.id, 
      categoryNames
    );
    
    await loadWords();
    toast.success("Categories updated");
    setIsCategoriesModalOpen(false);
  } catch (error) {
    toast.error("Failed to update categories");
  }
};
```

#### Service Method
```typescript
// wordService.ts
updateWordCategories: async (
  categoryId: string, 
  wordId: number, 
  categoryNames: string[]
): Promise<void> => {
  const service = new RequestService();
  const request = new RequestBuilder<{ categoryNames: string[] }>()
    .url(`/categories/${categoryId}/words/${wordId}/categories`)
    .method(HttpMethod.PATCH)
    .contentTypeHeader('application/json')
    .body({ categoryNames })
    .build();

  const res = await service.send<{ categoryNames: string[] }, void>(request);
  throwIfError(res, 'Failed to update categories');
}
```

#### User Flow
1. Double-click "In Categories" cell in table
2. Modal opens with category checkboxes
3. Select/deselect categories
4. Save changes
5. PATCH request sent to backend
6. Word list refreshed to show updated categories

---

## 6. Filtering & Sorting

### Overview
Filtering and sorting are performed **server-side** for better performance with large datasets. Query parameters are sent with the GET request, and the backend returns pre-filtered and sorted results.

### Filters (Both Accepted & Unaccepted)
1. **Text Filter**: Searches in word text and comments
2. **Mechanism Filter**: Filter by BASIC or TABLE mechanism

### Filter Query Parameters
```typescript
{
  searchText?: string;        // Search in word parts and comments
  mechanism?: "BASIC" | "TABLE" | "ALL";  // Mechanism filter
  accepted?: boolean;         // Separate calls for accepted/unaccepted
  chosen?: boolean;           // Optional: filter by chosen status
}
```

### Sorting Columns
Available sort columns:
- `word` - Alphabetical by combined word parts text
- `comment` - Alphabetical by comment
- `mechanism` - By mechanism type
- `chosen` - By chosen status
- `repeated` - By repetition count
- `lastTimestampRepeated` - By last repetition date
- `created` - By creation date

### Sort Query Parameters
```typescript
{
  sort?: string;              // Column name
  order?: "asc" | "desc";     // Sort direction
}
```

### Implementation Example
```typescript
const loadWords = async (accepted: boolean = true) => {
  const currentFilters = accepted ? {
    searchText: textFilter,
    mechanism: mechanismFilter,
    accepted: true
  } : {
    searchText: unacceptedTextFilter,
    mechanism: unacceptedMechanismFilter,
    accepted: false
  };
  
  const currentSort = accepted ? {
    column: sortColumn,
    direction: sortDirection
  } : {
    column: unacceptedSortColumn,
    direction: unacceptedSortDirection
  };
  
  const currentPagination = accepted ? {
    page: currentPage,
    pageSize: pageSize
  } : {
    page: unacceptedCurrentPage,
    pageSize: unacceptedPageSize
  };
  
  try {
    const response = await wordService.getWords(
      categoryId,
      currentFilters,
      currentPagination,
      currentSort
    );
    
    if (accepted) {
      setWords(response.items);
      setTotalPages(response.totalPages);
    } else {
      setUnacceptedWords(response.items);
      setUnacceptedTotalPages(response.totalPages);
    }
  } catch (error) {
    toast.error("Failed to load words");
  }
};
```

### Backend Processing
The backend should:
1. **Parse query parameters** from the request
2. **Apply filters** to the database query:
   - Text search: `WHERE word_text ILIKE '%{searchText}%' OR comment ILIKE '%{searchText}%'`
   - Mechanism: `WHERE mechanism = '{mechanism}'`
   - Accepted: `WHERE accepted = {true/false}`
3. **Apply sorting**: `ORDER BY {sort} {order}`
4. **Apply pagination**: `LIMIT {pageSize} OFFSET {(page-1) * pageSize}`
5. **Return paginated response** with metadata

### Filter/Sort State Management
```typescript
// Separate states for accepted and unaccepted words
const [textFilter, setTextFilter] = useState("");
const [mechanismFilter, setMechanismFilter] = useState<Mechanism | "ALL">("ALL");
const [sortColumn, setSortColumn] = useState<SortColumn | null>(null);
const [sortDirection, setSortDirection] = useState<SortDirection>("asc");

const [unacceptedTextFilter, setUnacceptedTextFilter] = useState("");
const [unacceptedMechanismFilter, setUnacceptedMechanismFilter] = useState<Mechanism | "ALL">("ALL");
const [unacceptedSortColumn, setUnacceptedSortColumn] = useState<SortColumn | null>(null);
const [unacceptedSortDirection, setUnacceptedSortDirection] = useState<SortDirection>("asc");
```

### Trigger Behavior
- Changing filters resets pagination to page 1
- Changing sort order maintains current page
- Each change triggers a new API call with updated parameters

---

## 7. Pagination

### Overview
Pagination is handled **server-side** to efficiently manage large datasets. Only the requested page of results is fetched from the backend.

### Pagination Query Parameters
```typescript
{
  page: number;        // Page number (1-based)
  pageSize: number;    // Items per page
}
```

### Backend Response Metadata
```typescript
{
  page: number;           // Current page number
  pageSize: number;       // Items per page
  total: number;          // Total number of matching items
  totalPages: number;     // Calculated: Math.ceil(total / pageSize)
  singlePage: boolean;    // true if total <= pageSize
  items: Word[];          // Current page items
}
```

### Features
- Separate pagination for accepted and unaccepted words
- Preset page sizes: 5, 10, 20, 50, 100, 1000, 5000
- Custom page size input
- Shows current page, total pages, and total items count

### Controls
- **Previous/Next buttons**: Navigate between pages
- **Page size dropdown**: Quick selection of common sizes
- **Custom page size input**: Enter any valid page size with "Apply" button

### Implementation
```typescript
const handlePageChange = async (newPage: number) => {
  setCurrentPage(newPage);
  await loadWords(); // Triggers new API call with updated page
};

const handlePageSizeChange = async (newPageSize: number) => {
  setPageSize(newPageSize);
  setCurrentPage(1); // Reset to first page
  await loadWords(); // Triggers new API call
};
```

### Page Size Change Behavior
```typescript
const handlePageSizeChange = (value: string) => {
  if (value === "custom") {
    return; // Wait for user to enter custom value
  }
  const newSize = Number(value);
  setPageSize(newSize);
  setCurrentPage(1); // Always reset to page 1
};

const handleCustomPageSize = () => {
  const size = Number(customPageSize);
  if (size > 0) {
    setPageSize(size);
    setCurrentPage(1);
    setCustomPageSize(""); // Clear input
  }
};
```

### State Management
```typescript
// Accepted words pagination
const [currentPage, setCurrentPage] = useState(1);
const [pageSize, setPageSize] = useState(20);
const [totalPages, setTotalPages] = useState(0);
const [customPageSize, setCustomPageSize] = useState("");

// Unaccepted words pagination
const [unacceptedCurrentPage, setUnacceptedCurrentPage] = useState(1);
const [unacceptedPageSize, setUnacceptedPageSize] = useState(20);
const [unacceptedTotalPages, setUnacceptedTotalPages] = useState(0);
const [unacceptedCustomPageSize, setUnacceptedCustomPageSize] = useState("");
```

### API Call Example
```typescript
// Request
GET /api/categories/{categoryId}/words?page=2&pageSize=20&accepted=true

// Response
{
  page: 2,
  pageSize: 20,
  total: 156,
  totalPages: 8,
  singlePage: false,
  items: [ /* 20 words */ ]
}
```

### Backend Implementation Notes
- Use `LIMIT` and `OFFSET` for SQL databases
- Calculate offset: `(page - 1) * pageSize`
- Always return total count for accurate pagination UI
- Consider caching total count if expensive to calculate

---

## 8. Data Persistence

### Storage Strategy
- **Technology**: Backend database (PostgreSQL, MySQL, MongoDB, etc.)
- **API Communication**: RESTful HTTP requests
- **Authentication**: Session-based with HTTP-only cookies
- **Data Format**: JSON for request/response bodies
- **Synchronization**: Immediate (every operation sends API request)

### Backend Database Schema Example
```sql
-- Words table
CREATE TABLE words (
  id SERIAL PRIMARY KEY,
  category_id UUID NOT NULL REFERENCES categories(uuid),
  accepted BOOLEAN DEFAULT FALSE,
  comment TEXT NOT NULL,
  mechanism VARCHAR(20) NOT NULL, -- 'BASIC' or 'TABLE'
  chosen BOOLEAN DEFAULT FALSE,
  to_repeat BOOLEAN DEFAULT FALSE,
  repeated INTEGER DEFAULT 0,
  last_timestamp_repeated BIGINT,
  created BIGINT NOT NULL,
  reset_timestamp BIGINT,
  CONSTRAINT fk_category FOREIGN KEY (category_id) 
    REFERENCES categories(uuid) ON DELETE CASCADE
);

-- Word parts table (one-to-many relationship)
CREATE TABLE word_parts (
  id SERIAL PRIMARY KEY,
  word_id INTEGER NOT NULL REFERENCES words(id) ON DELETE CASCADE,
  word TEXT NOT NULL,
  basic_word TEXT,
  answer BOOLEAN NOT NULL,
  to_speech BOOLEAN DEFAULT FALSE,
  position INTEGER NOT NULL,
  is_separator BOOLEAN DEFAULT FALSE,
  separator_type VARCHAR(20),
  CONSTRAINT fk_word FOREIGN KEY (word_id) 
    REFERENCES words(id) ON DELETE CASCADE
);

-- Word stats table (many repetition records per word)
CREATE TABLE word_stats (
  id SERIAL PRIMARY KEY,
  word_id INTEGER NOT NULL REFERENCES words(id) ON DELETE CASCADE,
  timestamp_repeated BIGINT NOT NULL,
  to_answer INTEGER NOT NULL,
  answered INTEGER NOT NULL,
  method VARCHAR(50) NOT NULL,
  CONSTRAINT fk_word_stat FOREIGN KEY (word_id) 
    REFERENCES words(id) ON DELETE CASCADE
);

-- Word-Category junction table (many-to-many)
CREATE TABLE word_categories (
  word_id INTEGER NOT NULL REFERENCES words(id) ON DELETE CASCADE,
  category_name VARCHAR(255) NOT NULL,
  PRIMARY KEY (word_id, category_name)
);

-- Indexes for performance
CREATE INDEX idx_words_category ON words(category_id);
CREATE INDEX idx_words_accepted ON words(accepted);
CREATE INDEX idx_words_chosen ON words(chosen);
CREATE INDEX idx_word_parts_word ON word_parts(word_id);
CREATE INDEX idx_word_parts_position ON word_parts(word_id, position);
CREATE INDEX idx_word_stats_word ON word_stats(word_id);
```

### Persistence Triggers
Each operation triggers an immediate API call:

| Operation | API Call | Result |
|-----------|----------|--------|
| Add new word | `POST /api/categories/{id}/words` | Word created in DB |
| Edit existing word | `PUT /api/categories/{id}/words/{wordId}` | Word updated in DB |
| Delete word | `DELETE /api/categories/{id}/words/{wordId}` | Word removed from DB |
| Accept word | `PATCH /api/categories/{id}/words/{wordId}/accept` | `accepted` flag updated |
| Reject word | `DELETE /api/categories/{id}/words/{wordId}` | Word removed from DB |
| Toggle chosen | `PATCH /api/categories/{id}/words/{wordId}/chosen` | `chosen` flag updated |
| Update categories | `PATCH /api/categories/{id}/words/{wordId}/categories` | Junction table updated |
| Load words | `GET /api/categories/{id}/words` | Words fetched from DB |

### Data Retention
- Data persists indefinitely in the backend database
- Controlled by database backup and retention policies
- Cascade deletes handle referential integrity:
  - Deleting a word removes all its word parts and stats
  - Deleting a category removes all its words
- No automatic expiration unless implemented by business logic

### Transaction Handling
Backend should use database transactions for data consistency:

```typescript
// Example backend transaction (Node.js/PostgreSQL)
async createWord(categoryId: string, wordData: WordCreateForm): Promise<Word> {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    // Insert word
    const wordResult = await client.query(
      'INSERT INTO words (category_id, comment, mechanism, accepted, created) VALUES ($1, $2, $3, $4, $5) RETURNING *',
      [categoryId, wordData.comment, wordData.mechanism, false, Date.now()]
    );
    const wordId = wordResult.rows[0].id;
    
    // Insert word parts
    for (const part of wordData.wordParts) {
      await client.query(
        'INSERT INTO word_parts (word_id, word, basic_word, answer, to_speech, position, is_separator, separator_type) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)',
        [wordId, part.word, part.basicWord, part.answer, part.toSpeech, part.position, part.isSeparator, part.separatorType]
      );
    }
    
    await client.query('COMMIT');
    return mapToWord(wordResult.rows[0]);
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

### Error Handling
Frontend should handle API errors gracefully:

```typescript
try {
  await wordService.createWord(categoryId, wordData);
  toast.success("Word added successfully");
} catch (error) {
  if (error.statusCode === 400) {
    toast.error("Invalid word data");
  } else if (error.statusCode === 401) {
    toast.error("Please log in to continue");
    navigate('/login');
  } else if (error.statusCode === 403) {
    toast.error("You don't have permission to add words");
  } else if (error.statusCode === 404) {
    toast.error("Category not found");
  } else {
    toast.error("Failed to add word. Please try again.");
  }
}
```

### Optimistic Updates
For better UX, consider optimistic updates for instant feedback:

```typescript
const handleChosenChange = async (wordId: number, checked: boolean) => {
  // Optimistic update
  setWords(words.map(w => w.id === wordId ? { ...w, chosen: checked } : w));
  
  try {
    await wordService.updateWordChosen(categoryId, wordId, checked);
  } catch (error) {
    // Revert on error
    setWords(words.map(w => w.id === wordId ? { ...w, chosen: !checked } : w));
    toast.error("Failed to update chosen status");
  }
};
```

---

## 9. Complete Request/Response Examples

### Example 1: Fetching Words (GET)

**Request:**
```http
GET /api/categories/550e8400-e29b-41d4-a716-446655440000/words?page=1&pageSize=20&accepted=true&sort=created&order=desc&searchText=hello&mechanism=BASIC
Authorization: <session-cookie>
```

**Response (200 OK):**
```json
{
  "page": 1,
  "pageSize": 20,
  "total": 45,
  "totalPages": 3,
  "sort": "created",
  "order": "desc",
  "singlePage": false,
  "items": [
    {
      "id": 1001,
      "accepted": true,
      "comment": "Common greeting",
      "resetTimestamp": null,
      "mechanism": "BASIC",
      "chosen": true,
      "toRepeat": false,
      "repeated": 5,
      "lastTimestampRepeated": 1699228800000,
      "created": 1699142400000,
      "wordParts": [
        {
          "word": "Hello",
          "basicWord": "hello",
          "answer": false,
          "toSpeech": false,
          "position": 0,
          "isSeparator": false,
          "separatorType": null
        },
        {
          "word": "Hola",
          "basicWord": "",
          "answer": true,
          "toSpeech": true,
          "position": 1,
          "isSeparator": false,
          "separatorType": null
        }
      ],
      "wordStats": [
        {
          "timestampRepeated": 1699228800000,
          "toAnswer": 1,
          "answered": 1,
          "method": "QuestionToAnswer"
        }
      ],
      "inCategories": ["Greetings", "Basic Phrases"]
    }
  ]
}
```

---

### Example 2: Creating a Word (POST)

**Request:**
```http
POST /api/categories/550e8400-e29b-41d4-a716-446655440000/words
Content-Type: application/json
Authorization: <session-cookie>

{
  "comment": "To eat - present tense conjugation",
  "mechanism": "TABLE",
  "wordParts": [
    {
      "word": "eat",
      "basicWord": "",
      "answer": false,
      "toSpeech": false,
      "position": 0,
      "isSeparator": false
    },
    {
      "word": "ENTER",
      "basicWord": "(representation for enter)",
      "answer": false,
      "toSpeech": false,
      "position": 1,
      "isSeparator": true,
      "separatorType": "ENTER"
    },
    {
      "word": "I",
      "basicWord": "",
      "answer": false,
      "toSpeech": false,
      "position": 2,
      "isSeparator": false
    },
    {
      "word": "como",
      "basicWord": "comer",
      "answer": true,
      "toSpeech": true,
      "position": 3,
      "isSeparator": false
    }
  ],
  "accepted": false,
  "chosen": false,
  "inCategories": []
}
```

**Response (201 Created):**
```json
{
  "id": 1002,
  "accepted": false,
  "comment": "To eat - present tense conjugation",
  "resetTimestamp": null,
  "mechanism": "TABLE",
  "chosen": false,
  "toRepeat": false,
  "repeated": 0,
  "lastTimestampRepeated": null,
  "created": 1730851200000,
  "wordParts": [
    {
      "word": "eat",
      "basicWord": "",
      "answer": false,
      "toSpeech": false,
      "position": 0,
      "isSeparator": false,
      "separatorType": null
    },
    {
      "word": "ENTER",
      "basicWord": "(representation for enter)",
      "answer": false,
      "toSpeech": false,
      "position": 1,
      "isSeparator": true,
      "separatorType": "ENTER"
    },
    {
      "word": "I",
      "basicWord": "",
      "answer": false,
      "toSpeech": false,
      "position": 2,
      "isSeparator": false,
      "separatorType": null
    },
    {
      "word": "como",
      "basicWord": "comer",
      "answer": true,
      "toSpeech": true,
      "position": 3,
      "isSeparator": false,
      "separatorType": null
    }
  ],
  "wordStats": [],
  "inCategories": []
}
```

---

### Example 3: Updating a Word (PUT)

**Request:**
```http
PUT /api/categories/550e8400-e29b-41d4-a716-446655440000/words/1002
Content-Type: application/json
Authorization: <session-cookie>

{
  "comment": "To eat - present tense conjugation (updated)",
  "mechanism": "TABLE",
  "chosen": true,
  "wordParts": [
    {
      "word": "to eat",
      "basicWord": "eat",
      "answer": false,
      "toSpeech": false,
      "position": 0,
      "isSeparator": false
    },
    {
      "word": "ENTER",
      "basicWord": "(representation for enter)",
      "answer": false,
      "toSpeech": false,
      "position": 1,
      "isSeparator": true,
      "separatorType": "ENTER"
    },
    {
      "word": "I",
      "basicWord": "",
      "answer": false,
      "toSpeech": false,
      "position": 2,
      "isSeparator": false
    },
    {
      "word": "como",
      "basicWord": "comer",
      "answer": true,
      "toSpeech": true,
      "position": 3,
      "isSeparator": false
    }
  ],
  "inCategories": ["Verbs", "Food"]
}
```

**Response (200 OK):**
```json
{
  "id": 1002,
  "accepted": false,
  "comment": "To eat - present tense conjugation (updated)",
  "resetTimestamp": null,
  "mechanism": "TABLE",
  "chosen": true,
  "toRepeat": false,
  "repeated": 0,
  "lastTimestampRepeated": null,
  "created": 1730851200000,
  "wordParts": [
    {
      "word": "to eat",
      "basicWord": "eat",
      "answer": false,
      "toSpeech": false,
      "position": 0,
      "isSeparator": false,
      "separatorType": null
    },
    {
      "word": "ENTER",
      "basicWord": "(representation for enter)",
      "answer": false,
      "toSpeech": false,
      "position": 1,
      "isSeparator": true,
      "separatorType": "ENTER"
    },
    {
      "word": "I",
      "basicWord": "",
      "answer": false,
      "toSpeech": false,
      "position": 2,
      "isSeparator": false,
      "separatorType": null
    },
    {
      "word": "como",
      "basicWord": "comer",
      "answer": true,
      "toSpeech": true,
      "position": 3,
      "isSeparator": false,
      "separatorType": null
    }
  ],
  "wordStats": [],
  "inCategories": ["Verbs", "Food"]
}
```

---

### Example 4: Deleting a Word (DELETE)

**Request:**
```http
DELETE /api/categories/550e8400-e29b-41d4-a716-446655440000/words/1002
Authorization: <session-cookie>
```

**Response (204 No Content):**
```
(empty body)
```

---

### Example 5: Accepting a Word (PATCH)

**Request:**
```http
PATCH /api/categories/550e8400-e29b-41d4-a716-446655440000/words/1003/accept
Authorization: <session-cookie>
```

**Response (200 OK):**
```json
{
  "id": 1003,
  "accepted": true,
  "comment": "Basic verb",
  "resetTimestamp": null,
  "mechanism": "BASIC",
  "chosen": false,
  "toRepeat": false,
  "repeated": 0,
  "lastTimestampRepeated": null,
  "created": 1730937600000,
  "wordParts": [ /* ... */ ],
  "wordStats": [],
  "inCategories": []
}
```

---

### Example 6: Updating Chosen Status (PATCH)

**Request:**
```http
PATCH /api/categories/550e8400-e29b-41d4-a716-446655440000/words/1001/chosen
Content-Type: application/json
Authorization: <session-cookie>

{
  "chosen": true
}
```

**Response (200 OK):**
```json
{
  "id": 1001,
  "chosen": true,
  "accepted": true,
  "comment": "Common greeting",
  "mechanism": "BASIC",
  "toRepeat": false,
  "repeated": 5,
  "lastTimestampRepeated": 1699228800000,
  "created": 1699142400000,
  "resetTimestamp": null,
  "wordParts": [ /* ... */ ],
  "wordStats": [ /* ... */ ],
  "inCategories": ["Greetings", "Basic Phrases"]
}
```

---

### Example 7: Updating Categories (PATCH)

**Request:**
```http
PATCH /api/categories/550e8400-e29b-41d4-a716-446655440000/words/1001/categories
Content-Type: application/json
Authorization: <session-cookie>

{
  "categoryNames": ["Greetings", "Basic Phrases", "Daily Conversations"]
}
```

**Response (200 OK):**
```json
{
  "id": 1001,
  "accepted": true,
  "comment": "Common greeting",
  "mechanism": "BASIC",
  "chosen": true,
  "toRepeat": false,
  "repeated": 5,
  "lastTimestampRepeated": 1699228800000,
  "created": 1699142400000,
  "resetTimestamp": null,
  "wordParts": [ /* ... */ ],
  "wordStats": [ /* ... */ ],
  "inCategories": ["Greetings", "Basic Phrases", "Daily Conversations"]
}
```

---

### Example 8: Error Response (400 Bad Request)

**Request:**
```http
POST /api/categories/550e8400-e29b-41d4-a716-446655440000/words
Content-Type: application/json
Authorization: <session-cookie>

{
  "comment": "",
  "mechanism": "INVALID_TYPE",
  "wordParts": []
}
```

**Response (400 Bad Request):**
```json
{
  "statusCode": 400,
  "message": "Validation failed",
  "errors": [
    {
      "field": "comment",
      "message": "Comment cannot be empty"
    },
    {
      "field": "mechanism",
      "message": "Mechanism must be either BASIC or TABLE"
    },
    {
      "field": "wordParts",
      "message": "At least one word part is required"
    }
  ]
}
```

---

## 10. Word Display Format

### Rendering Word Parts
Word parts are displayed in order by `position` field with special formatting:
- **Answer parts**: Highlighted with primary color background
- **Basic words**: Shown in parentheses next to main word
- **Separators**: 
  - ENTER: Creates new line
  - TAB: Adds spacing
  - MULTI_DASH: Shows "----------"

### Table Columns
1. Word (with formatted parts)
2. Comment
3. Mechanism badge
4. Chosen checkbox
5. Repeated count
6. In Categories (with tooltip)
7. Created date
8. Last Repeated date
9. Actions (Edit & Delete buttons)

---

## Summary

The Category View implements a complete CRUD system for word management with:
- ✅ **Create**: Add new words with multi-part structure via POST API
- ✅ **Read**: Fetch and display words with server-side filtering/sorting/pagination via GET API
- ✅ **Update**: Edit existing words via modal form and PUT API
- ✅ **Delete**: Remove words permanently via DELETE API
- ✅ **Storage**: Backend database persistence with RESTful API
- ✅ **Partial Updates**: PATCH endpoints for specific field updates (chosen, categories, accept)
- ✅ **UI**: Rich features including drag-drop, keyboard shortcuts, and special characters
- ✅ **Performance**: Server-side pagination and filtering for large datasets
- ✅ **Error Handling**: Comprehensive error handling with user feedback
- ✅ **Optimistic Updates**: Instant UI feedback with server synchronization

---

## Complete API Reference

### Endpoints Summary

| Method | Endpoint | Purpose | Request Body | Response |
|--------|----------|---------|--------------|----------|
| GET | `/api/categories/{id}/words` | Fetch paginated words | Query params | PageDto<Word> |
| POST | `/api/categories/{id}/words` | Create new word | WordCreateForm | Word |
| PUT | `/api/categories/{id}/words/{wordId}` | Update word | WordUpdateForm | Word |
| DELETE | `/api/categories/{id}/words/{wordId}` | Delete word | None | 204 No Content |
| PATCH | `/api/categories/{id}/words/{wordId}/accept` | Accept word | None | Word |
| PATCH | `/api/categories/{id}/words/{wordId}/chosen` | Toggle chosen | { chosen: boolean } | Word |
| PATCH | `/api/categories/{id}/words/{wordId}/categories` | Update categories | { categoryNames: string[] } | Word |

### Common Response Codes

| Code | Meaning | When |
|------|---------|------|
| 200 | OK | Successful GET, PUT, PATCH |
| 201 | Created | Successful POST |
| 204 | No Content | Successful DELETE |
| 400 | Bad Request | Invalid request body or parameters |
| 401 | Unauthorized | Not authenticated |
| 403 | Forbidden | No permission for this resource |
| 404 | Not Found | Category or word not found |
| 500 | Server Error | Internal server error |

### Authentication
All endpoints require authentication via HTTP-only session cookies set during login.

